// Code generated by mockery v2.13.1. DO NOT EDIT.

package mocks

import (
	ctx "github.com/x-xyz/goapi/base/ctx"
	account "github.com/x-xyz/goapi/domain/account"

	domain "github.com/x-xyz/goapi/domain"

	mock "github.com/stretchr/testify/mock"
)

// Usecase is an autogenerated mock type for the Usecase type
type Usecase struct {
	mock.Mock
}

// Ban provides a mock function with given fields: c, address
func (_m *Usecase) Ban(c ctx.Ctx, address domain.Address) error {
	ret := _m.Called(c, address)

	var r0 error
	if rf, ok := ret.Get(0).(func(ctx.Ctx, domain.Address) error); ok {
		r0 = rf(c, address)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Create provides a mock function with given fields: c, address
func (_m *Usecase) Create(c ctx.Ctx, address domain.Address) (*account.Info, error) {
	ret := _m.Called(c, address)

	var r0 *account.Info
	if rf, ok := ret.Get(0).(func(ctx.Ctx, domain.Address) *account.Info); ok {
		r0 = rf(c, address)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*account.Info)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(ctx.Ctx, domain.Address) error); ok {
		r1 = rf(c, address)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Follow provides a mock function with given fields: c, address, toAddress
func (_m *Usecase) Follow(c ctx.Ctx, address domain.Address, toAddress domain.Address) error {
	ret := _m.Called(c, address, toAddress)

	var r0 error
	if rf, ok := ret.Get(0).(func(ctx.Ctx, domain.Address, domain.Address) error); ok {
		r0 = rf(c, address, toAddress)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// GenerateNonce provides a mock function with given fields: c, address
func (_m *Usecase) GenerateNonce(c ctx.Ctx, address domain.Address) (int32, error) {
	ret := _m.Called(c, address)

	var r0 int32
	if rf, ok := ret.Get(0).(func(ctx.Ctx, domain.Address) int32); ok {
		r0 = rf(c, address)
	} else {
		r0 = ret.Get(0).(int32)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(ctx.Ctx, domain.Address) error); ok {
		r1 = rf(c, address)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Get provides a mock function with given fields: c, address
func (_m *Usecase) Get(c ctx.Ctx, address domain.Address) (*account.Info, error) {
	ret := _m.Called(c, address)

	var r0 *account.Info
	if rf, ok := ret.Get(0).(func(ctx.Ctx, domain.Address) *account.Info); ok {
		r0 = rf(c, address)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*account.Info)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(ctx.Ctx, domain.Address) error); ok {
		r1 = rf(c, address)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAccountCollectionHoldings provides a mock function with given fields: c, address
func (_m *Usecase) GetAccountCollectionHoldings(c ctx.Ctx, address domain.Address) (*account.AccountCollectionHoldings, error) {
	ret := _m.Called(c, address)

	var r0 *account.AccountCollectionHoldings
	if rf, ok := ret.Get(0).(func(ctx.Ctx, domain.Address) *account.AccountCollectionHoldings); ok {
		r0 = rf(c, address)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*account.AccountCollectionHoldings)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(ctx.Ctx, domain.Address) error); ok {
		r1 = rf(c, address)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAccountStat provides a mock function with given fields: c, address
func (_m *Usecase) GetAccountStat(c ctx.Ctx, address domain.Address) (*account.AccountStat, error) {
	ret := _m.Called(c, address)

	var r0 *account.AccountStat
	if rf, ok := ret.Get(0).(func(ctx.Ctx, domain.Address) *account.AccountStat); ok {
		r0 = rf(c, address)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*account.AccountStat)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(ctx.Ctx, domain.Address) error); ok {
		r1 = rf(c, address)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetActivities provides a mock function with given fields: c, address, opts
func (_m *Usecase) GetActivities(c ctx.Ctx, address domain.Address, opts ...account.FindActivityHistoryOptions) (*account.ActivityResult, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, c, address)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *account.ActivityResult
	if rf, ok := ret.Get(0).(func(ctx.Ctx, domain.Address, ...account.FindActivityHistoryOptions) *account.ActivityResult); ok {
		r0 = rf(c, address, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*account.ActivityResult)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(ctx.Ctx, domain.Address, ...account.FindActivityHistoryOptions) error); ok {
		r1 = rf(c, address, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetFollowers provides a mock function with given fields: c, address
func (_m *Usecase) GetFollowers(c ctx.Ctx, address domain.Address) ([]*account.Info, error) {
	ret := _m.Called(c, address)

	var r0 []*account.Info
	if rf, ok := ret.Get(0).(func(ctx.Ctx, domain.Address) []*account.Info); ok {
		r0 = rf(c, address)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*account.Info)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(ctx.Ctx, domain.Address) error); ok {
		r1 = rf(c, address)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetFollowings provides a mock function with given fields: c, address
func (_m *Usecase) GetFollowings(c ctx.Ctx, address domain.Address) ([]*account.Info, error) {
	ret := _m.Called(c, address)

	var r0 []*account.Info
	if rf, ok := ret.Get(0).(func(ctx.Ctx, domain.Address) []*account.Info); ok {
		r0 = rf(c, address)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*account.Info)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(ctx.Ctx, domain.Address) error); ok {
		r1 = rf(c, address)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetNotificationSettings provides a mock function with given fields: c, address
func (_m *Usecase) GetNotificationSettings(c ctx.Ctx, address domain.Address) (*account.NotificationSettings, error) {
	ret := _m.Called(c, address)

	var r0 *account.NotificationSettings
	if rf, ok := ret.Get(0).(func(ctx.Ctx, domain.Address) *account.NotificationSettings); ok {
		r0 = rf(c, address)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*account.NotificationSettings)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(ctx.Ctx, domain.Address) error); ok {
		r1 = rf(c, address)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetPendingOffers provides a mock function with given fields: c, address, opts
func (_m *Usecase) GetPendingOffers(c ctx.Ctx, address domain.Address, opts ...account.FindPendingOfferOptions) (*account.PendingOfferResult, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, c, address)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *account.PendingOfferResult
	if rf, ok := ret.Get(0).(func(ctx.Ctx, domain.Address, ...account.FindPendingOfferOptions) *account.PendingOfferResult); ok {
		r0 = rf(c, address, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*account.PendingOfferResult)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(ctx.Ctx, domain.Address, ...account.FindPendingOfferOptions) error); ok {
		r1 = rf(c, address, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IsFollowing provides a mock function with given fields: c, address, toAddress
func (_m *Usecase) IsFollowing(c ctx.Ctx, address domain.Address, toAddress domain.Address) (bool, error) {
	ret := _m.Called(c, address, toAddress)

	var r0 bool
	if rf, ok := ret.Get(0).(func(ctx.Ctx, domain.Address, domain.Address) bool); ok {
		r0 = rf(c, address, toAddress)
	} else {
		r0 = ret.Get(0).(bool)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(ctx.Ctx, domain.Address, domain.Address) error); ok {
		r1 = rf(c, address, toAddress)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Unban provides a mock function with given fields: c, address
func (_m *Usecase) Unban(c ctx.Ctx, address domain.Address) error {
	ret := _m.Called(c, address)

	var r0 error
	if rf, ok := ret.Get(0).(func(ctx.Ctx, domain.Address) error); ok {
		r0 = rf(c, address)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Unfollow provides a mock function with given fields: c, address, toAddress
func (_m *Usecase) Unfollow(c ctx.Ctx, address domain.Address, toAddress domain.Address) error {
	ret := _m.Called(c, address, toAddress)

	var r0 error
	if rf, ok := ret.Get(0).(func(ctx.Ctx, domain.Address, domain.Address) error); ok {
		r0 = rf(c, address, toAddress)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Update provides a mock function with given fields: c, address, updater
func (_m *Usecase) Update(c ctx.Ctx, address domain.Address, updater *account.Updater) (*account.Info, error) {
	ret := _m.Called(c, address, updater)

	var r0 *account.Info
	if rf, ok := ret.Get(0).(func(ctx.Ctx, domain.Address, *account.Updater) *account.Info); ok {
		r0 = rf(c, address, updater)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*account.Info)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(ctx.Ctx, domain.Address, *account.Updater) error); ok {
		r1 = rf(c, address, updater)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateAvatar provides a mock function with given fields: c, address, imgData
func (_m *Usecase) UpdateAvatar(c ctx.Ctx, address domain.Address, imgData string) (string, error) {
	ret := _m.Called(c, address, imgData)

	var r0 string
	if rf, ok := ret.Get(0).(func(ctx.Ctx, domain.Address, string) string); ok {
		r0 = rf(c, address, imgData)
	} else {
		r0 = ret.Get(0).(string)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(ctx.Ctx, domain.Address, string) error); ok {
		r1 = rf(c, address, imgData)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateBanner provides a mock function with given fields: c, address, imgData
func (_m *Usecase) UpdateBanner(c ctx.Ctx, address domain.Address, imgData string) (string, error) {
	ret := _m.Called(c, address, imgData)

	var r0 string
	if rf, ok := ret.Get(0).(func(ctx.Ctx, domain.Address, string) string); ok {
		r0 = rf(c, address, imgData)
	} else {
		r0 = ret.Get(0).(string)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(ctx.Ctx, domain.Address, string) error); ok {
		r1 = rf(c, address, imgData)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpsertNotificationSettings provides a mock function with given fields: c, settings
func (_m *Usecase) UpsertNotificationSettings(c ctx.Ctx, settings *account.NotificationSettings) (*account.NotificationSettings, error) {
	ret := _m.Called(c, settings)

	var r0 *account.NotificationSettings
	if rf, ok := ret.Get(0).(func(ctx.Ctx, *account.NotificationSettings) *account.NotificationSettings); ok {
		r0 = rf(c, settings)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*account.NotificationSettings)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(ctx.Ctx, *account.NotificationSettings) error); ok {
		r1 = rf(c, settings)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UseOrderNonce provides a mock function with given fields: c, address
func (_m *Usecase) UseOrderNonce(c ctx.Ctx, address domain.Address) (string, error) {
	ret := _m.Called(c, address)

	var r0 string
	if rf, ok := ret.Get(0).(func(ctx.Ctx, domain.Address) string); ok {
		r0 = rf(c, address)
	} else {
		r0 = ret.Get(0).(string)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(ctx.Ctx, domain.Address) error); ok {
		r1 = rf(c, address)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UseOrderNonceIfNeeded provides a mock function with given fields: c, address, nonce
func (_m *Usecase) UseOrderNonceIfNeeded(c ctx.Ctx, address domain.Address, nonce string) error {
	ret := _m.Called(c, address, nonce)

	var r0 error
	if rf, ok := ret.Get(0).(func(ctx.Ctx, domain.Address, string) error); ok {
		r0 = rf(c, address, nonce)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ValidateSignature provides a mock function with given fields: c, address, signature
func (_m *Usecase) ValidateSignature(c ctx.Ctx, address domain.Address, signature string) error {
	ret := _m.Called(c, address, signature)

	var r0 error
	if rf, ok := ret.Get(0).(func(ctx.Ctx, domain.Address, string) error); ok {
		r0 = rf(c, address, signature)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

type mockConstructorTestingTNewUsecase interface {
	mock.TestingT
	Cleanup(func())
}

// NewUsecase creates a new instance of Usecase. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
func NewUsecase(t mockConstructorTestingTNewUsecase) *Usecase {
	mock := &Usecase{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
