// Code generated by mockery v2.9.4. DO NOT EDIT.

package mocks

import (
	mock "github.com/stretchr/testify/mock"
	ctx "github.com/x-xyz/goapi/base/ctx"

	redigoredis "github.com/gomodule/redigo/redis"

	redis "github.com/x-xyz/goapi/service/redis"

	time "time"
)

// Service is an autogenerated mock type for the Service type
type Service struct {
	mock.Mock
}

// Del provides a mock function with given fields: context, keys
func (_m *Service) Del(context ctx.Ctx, keys ...string) (int, error) {
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, context)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 int
	if rf, ok := ret.Get(0).(func(ctx.Ctx, ...string) int); ok {
		r0 = rf(context, keys...)
	} else {
		r0 = ret.Get(0).(int)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(ctx.Ctx, ...string) error); ok {
		r1 = rf(context, keys...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Exists provides a mock function with given fields: context, key
func (_m *Service) Exists(context ctx.Ctx, key string) (bool, error) {
	ret := _m.Called(context, key)

	var r0 bool
	if rf, ok := ret.Get(0).(func(ctx.Ctx, string) bool); ok {
		r0 = rf(context, key)
	} else {
		r0 = ret.Get(0).(bool)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(ctx.Ctx, string) error); ok {
		r1 = rf(context, key)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Expire provides a mock function with given fields: context, key, ttl
func (_m *Service) Expire(context ctx.Ctx, key string, ttl time.Duration) error {
	ret := _m.Called(context, key, ttl)

	var r0 error
	if rf, ok := ret.Get(0).(func(ctx.Ctx, string, time.Duration) error); ok {
		r0 = rf(context, key, ttl)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Get provides a mock function with given fields: context, key
func (_m *Service) Get(context ctx.Ctx, key string) ([]byte, error) {
	ret := _m.Called(context, key)

	var r0 []byte
	if rf, ok := ret.Get(0).(func(ctx.Ctx, string) []byte); ok {
		r0 = rf(context, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(ctx.Ctx, string) error); ok {
		r1 = rf(context, key)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetConn provides a mock function with given fields:
func (_m *Service) GetConn() (redigoredis.Conn, error) {
	ret := _m.Called()

	var r0 redigoredis.Conn
	if rf, ok := ret.Get(0).(func() redigoredis.Conn); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(redigoredis.Conn)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetSet provides a mock function with given fields: context, key, val, ttl
func (_m *Service) GetSet(context ctx.Ctx, key string, val []byte, ttl time.Duration) ([]byte, error) {
	ret := _m.Called(context, key, val, ttl)

	var r0 []byte
	if rf, ok := ret.Get(0).(func(ctx.Ctx, string, []byte, time.Duration) []byte); ok {
		r0 = rf(context, key, val, ttl)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(ctx.Ctx, string, []byte, time.Duration) error); ok {
		r1 = rf(context, key, val, ttl)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetStruct provides a mock function with given fields: context, key, val
func (_m *Service) GetStruct(context ctx.Ctx, key string, val interface{}) error {
	ret := _m.Called(context, key, val)

	var r0 error
	if rf, ok := ret.Get(0).(func(ctx.Ctx, string, interface{}) error); ok {
		r0 = rf(context, key, val)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// GetZip provides a mock function with given fields: context, key
func (_m *Service) GetZip(context ctx.Ctx, key string) ([]byte, error) {
	ret := _m.Called(context, key)

	var r0 []byte
	if rf, ok := ret.Get(0).(func(ctx.Ctx, string) []byte); ok {
		r0 = rf(context, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(ctx.Ctx, string) error); ok {
		r1 = rf(context, key)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// HDel provides a mock function with given fields: context, key, field
func (_m *Service) HDel(context ctx.Ctx, key string, field string) (int, error) {
	ret := _m.Called(context, key, field)

	var r0 int
	if rf, ok := ret.Get(0).(func(ctx.Ctx, string, string) int); ok {
		r0 = rf(context, key, field)
	} else {
		r0 = ret.Get(0).(int)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(ctx.Ctx, string, string) error); ok {
		r1 = rf(context, key, field)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// HGet provides a mock function with given fields: context, key, field
func (_m *Service) HGet(context ctx.Ctx, key string, field string) ([]byte, error) {
	ret := _m.Called(context, key, field)

	var r0 []byte
	if rf, ok := ret.Get(0).(func(ctx.Ctx, string, string) []byte); ok {
		r0 = rf(context, key, field)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(ctx.Ctx, string, string) error); ok {
		r1 = rf(context, key, field)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// HGetAll provides a mock function with given fields: context, key
func (_m *Service) HGetAll(context ctx.Ctx, key string) (map[string][]byte, error) {
	ret := _m.Called(context, key)

	var r0 map[string][]byte
	if rf, ok := ret.Get(0).(func(ctx.Ctx, string) map[string][]byte); ok {
		r0 = rf(context, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string][]byte)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(ctx.Ctx, string) error); ok {
		r1 = rf(context, key)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// HIncrby provides a mock function with given fields: context, key, field, val
func (_m *Service) HIncrby(context ctx.Ctx, key string, field string, val int) (int64, error) {
	ret := _m.Called(context, key, field, val)

	var r0 int64
	if rf, ok := ret.Get(0).(func(ctx.Ctx, string, string, int) int64); ok {
		r0 = rf(context, key, field, val)
	} else {
		r0 = ret.Get(0).(int64)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(ctx.Ctx, string, string, int) error); ok {
		r1 = rf(context, key, field, val)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// HLen provides a mock function with given fields: context, key
func (_m *Service) HLen(context ctx.Ctx, key string) (int, error) {
	ret := _m.Called(context, key)

	var r0 int
	if rf, ok := ret.Get(0).(func(ctx.Ctx, string) int); ok {
		r0 = rf(context, key)
	} else {
		r0 = ret.Get(0).(int)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(ctx.Ctx, string) error); ok {
		r1 = rf(context, key)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// HMGet provides a mock function with given fields: context, key, fields
func (_m *Service) HMGet(context ctx.Ctx, key string, fields ...string) ([]redis.MVal, error) {
	_va := make([]interface{}, len(fields))
	for _i := range fields {
		_va[_i] = fields[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, context, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 []redis.MVal
	if rf, ok := ret.Get(0).(func(ctx.Ctx, string, ...string) []redis.MVal); ok {
		r0 = rf(context, key, fields...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]redis.MVal)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(ctx.Ctx, string, ...string) error); ok {
		r1 = rf(context, key, fields...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// HMSet provides a mock function with given fields: context, key, fieldVal, ttl
func (_m *Service) HMSet(context ctx.Ctx, key string, fieldVal map[string][]byte, ttl time.Duration) error {
	ret := _m.Called(context, key, fieldVal, ttl)

	var r0 error
	if rf, ok := ret.Get(0).(func(ctx.Ctx, string, map[string][]byte, time.Duration) error); ok {
		r0 = rf(context, key, fieldVal, ttl)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// HScan provides a mock function with given fields: context, key, cursor, count
func (_m *Service) HScan(context ctx.Ctx, key string, cursor int, count int) (map[string][]byte, int, error) {
	ret := _m.Called(context, key, cursor, count)

	var r0 map[string][]byte
	if rf, ok := ret.Get(0).(func(ctx.Ctx, string, int, int) map[string][]byte); ok {
		r0 = rf(context, key, cursor, count)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string][]byte)
		}
	}

	var r1 int
	if rf, ok := ret.Get(1).(func(ctx.Ctx, string, int, int) int); ok {
		r1 = rf(context, key, cursor, count)
	} else {
		r1 = ret.Get(1).(int)
	}

	var r2 error
	if rf, ok := ret.Get(2).(func(ctx.Ctx, string, int, int) error); ok {
		r2 = rf(context, key, cursor, count)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// HSet provides a mock function with given fields: context, key, field, val, ttl
func (_m *Service) HSet(context ctx.Ctx, key string, field string, val []byte, ttl time.Duration) error {
	ret := _m.Called(context, key, field, val, ttl)

	var r0 error
	if rf, ok := ret.Get(0).(func(ctx.Ctx, string, string, []byte, time.Duration) error); ok {
		r0 = rf(context, key, field, val, ttl)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// HSetNX provides a mock function with given fields: context, key, field, val, ttl
func (_m *Service) HSetNX(context ctx.Ctx, key string, field string, val []byte, ttl time.Duration) (bool, error) {
	ret := _m.Called(context, key, field, val, ttl)

	var r0 bool
	if rf, ok := ret.Get(0).(func(ctx.Ctx, string, string, []byte, time.Duration) bool); ok {
		r0 = rf(context, key, field, val, ttl)
	} else {
		r0 = ret.Get(0).(bool)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(ctx.Ctx, string, string, []byte, time.Duration) error); ok {
		r1 = rf(context, key, field, val, ttl)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Incr provides a mock function with given fields: context, key
func (_m *Service) Incr(context ctx.Ctx, key string) (int64, error) {
	ret := _m.Called(context, key)

	var r0 int64
	if rf, ok := ret.Get(0).(func(ctx.Ctx, string) int64); ok {
		r0 = rf(context, key)
	} else {
		r0 = ret.Get(0).(int64)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(ctx.Ctx, string) error); ok {
		r1 = rf(context, key)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Incrby provides a mock function with given fields: context, key, val
func (_m *Service) Incrby(context ctx.Ctx, key string, val int) (int64, error) {
	ret := _m.Called(context, key, val)

	var r0 int64
	if rf, ok := ret.Get(0).(func(ctx.Ctx, string, int) int64); ok {
		r0 = rf(context, key, val)
	} else {
		r0 = ret.Get(0).(int64)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(ctx.Ctx, string, int) error); ok {
		r1 = rf(context, key, val)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// LIndex provides a mock function with given fields: context, key, index
func (_m *Service) LIndex(context ctx.Ctx, key string, index int64) ([]byte, error) {
	ret := _m.Called(context, key, index)

	var r0 []byte
	if rf, ok := ret.Get(0).(func(ctx.Ctx, string, int64) []byte); ok {
		r0 = rf(context, key, index)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(ctx.Ctx, string, int64) error); ok {
		r1 = rf(context, key, index)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// LInsert provides a mock function with given fields: context, key, before, val
func (_m *Service) LInsert(context ctx.Ctx, key string, before []byte, val []byte) error {
	ret := _m.Called(context, key, before, val)

	var r0 error
	if rf, ok := ret.Get(0).(func(ctx.Ctx, string, []byte, []byte) error); ok {
		r0 = rf(context, key, before, val)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// LLen provides a mock function with given fields: context, key
func (_m *Service) LLen(context ctx.Ctx, key string) (int, error) {
	ret := _m.Called(context, key)

	var r0 int
	if rf, ok := ret.Get(0).(func(ctx.Ctx, string) int); ok {
		r0 = rf(context, key)
	} else {
		r0 = ret.Get(0).(int)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(ctx.Ctx, string) error); ok {
		r1 = rf(context, key)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// LPop provides a mock function with given fields: context, key
func (_m *Service) LPop(context ctx.Ctx, key string) ([]byte, error) {
	ret := _m.Called(context, key)

	var r0 []byte
	if rf, ok := ret.Get(0).(func(ctx.Ctx, string) []byte); ok {
		r0 = rf(context, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(ctx.Ctx, string) error); ok {
		r1 = rf(context, key)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// LPush provides a mock function with given fields: context, key, val
func (_m *Service) LPush(context ctx.Ctx, key string, val []byte) error {
	ret := _m.Called(context, key, val)

	var r0 error
	if rf, ok := ret.Get(0).(func(ctx.Ctx, string, []byte) error); ok {
		r0 = rf(context, key, val)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// LRange provides a mock function with given fields: context, key, offset, count
func (_m *Service) LRange(context ctx.Ctx, key string, offset int, count int) ([][]byte, error) {
	ret := _m.Called(context, key, offset, count)

	var r0 [][]byte
	if rf, ok := ret.Get(0).(func(ctx.Ctx, string, int, int) [][]byte); ok {
		r0 = rf(context, key, offset, count)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([][]byte)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(ctx.Ctx, string, int, int) error); ok {
		r1 = rf(context, key, offset, count)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// LSet provides a mock function with given fields: context, key, index, val
func (_m *Service) LSet(context ctx.Ctx, key string, index int, val []byte) error {
	ret := _m.Called(context, key, index, val)

	var r0 error
	if rf, ok := ret.Get(0).(func(ctx.Ctx, string, int, []byte) error); ok {
		r0 = rf(context, key, index, val)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// LTrim provides a mock function with given fields: context, key, start, end
func (_m *Service) LTrim(context ctx.Ctx, key string, start int, end int) error {
	ret := _m.Called(context, key, start, end)

	var r0 error
	if rf, ok := ret.Get(0).(func(ctx.Ctx, string, int, int) error); ok {
		r0 = rf(context, key, start, end)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MGet provides a mock function with given fields: context, keys
func (_m *Service) MGet(context ctx.Ctx, keys []string) ([]redis.MVal, error) {
	ret := _m.Called(context, keys)

	var r0 []redis.MVal
	if rf, ok := ret.Get(0).(func(ctx.Ctx, []string) []redis.MVal); ok {
		r0 = rf(context, keys)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]redis.MVal)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(ctx.Ctx, []string) error); ok {
		r1 = rf(context, keys)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MGetZip provides a mock function with given fields: context, keys
func (_m *Service) MGetZip(context ctx.Ctx, keys []string) ([]redis.MVal, error) {
	ret := _m.Called(context, keys)

	var r0 []redis.MVal
	if rf, ok := ret.Get(0).(func(ctx.Ctx, []string) []redis.MVal); ok {
		r0 = rf(context, keys)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]redis.MVal)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(ctx.Ctx, []string) error); ok {
		r1 = rf(context, keys)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MSet provides a mock function with given fields: context, keyVals, ttl
func (_m *Service) MSet(context ctx.Ctx, keyVals map[string][]byte, ttl time.Duration) error {
	ret := _m.Called(context, keyVals, ttl)

	var r0 error
	if rf, ok := ret.Get(0).(func(ctx.Ctx, map[string][]byte, time.Duration) error); ok {
		r0 = rf(context, keyVals, ttl)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Name provides a mock function with given fields:
func (_m *Service) Name() string {
	ret := _m.Called()

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// PFAdd provides a mock function with given fields: context, key, members
func (_m *Service) PFAdd(context ctx.Ctx, key string, members ...string) (int, error) {
	_va := make([]interface{}, len(members))
	for _i := range members {
		_va[_i] = members[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, context, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 int
	if rf, ok := ret.Get(0).(func(ctx.Ctx, string, ...string) int); ok {
		r0 = rf(context, key, members...)
	} else {
		r0 = ret.Get(0).(int)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(ctx.Ctx, string, ...string) error); ok {
		r1 = rf(context, key, members...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RPop provides a mock function with given fields: context, key
func (_m *Service) RPop(context ctx.Ctx, key string) ([]byte, error) {
	ret := _m.Called(context, key)

	var r0 []byte
	if rf, ok := ret.Get(0).(func(ctx.Ctx, string) []byte); ok {
		r0 = rf(context, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(ctx.Ctx, string) error); ok {
		r1 = rf(context, key)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RPush provides a mock function with given fields: context, key, val
func (_m *Service) RPush(context ctx.Ctx, key string, val []byte) (int, error) {
	ret := _m.Called(context, key, val)

	var r0 int
	if rf, ok := ret.Get(0).(func(ctx.Ctx, string, []byte) int); ok {
		r0 = rf(context, key, val)
	} else {
		r0 = ret.Get(0).(int)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(ctx.Ctx, string, []byte) error); ok {
		r1 = rf(context, key, val)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RandomKey provides a mock function with given fields: context
func (_m *Service) RandomKey(context ctx.Ctx) ([]byte, error) {
	ret := _m.Called(context)

	var r0 []byte
	if rf, ok := ret.Get(0).(func(ctx.Ctx) []byte); ok {
		r0 = rf(context)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(ctx.Ctx) error); ok {
		r1 = rf(context)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Rename provides a mock function with given fields: context, oldKey, newKey
func (_m *Service) Rename(context ctx.Ctx, oldKey string, newKey string) error {
	ret := _m.Called(context, oldKey, newKey)

	var r0 error
	if rf, ok := ret.Get(0).(func(ctx.Ctx, string, string) error); ok {
		r0 = rf(context, oldKey, newKey)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SAdd provides a mock function with given fields: context, key, member
func (_m *Service) SAdd(context ctx.Ctx, key string, member ...string) error {
	_va := make([]interface{}, len(member))
	for _i := range member {
		_va[_i] = member[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, context, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 error
	if rf, ok := ret.Get(0).(func(ctx.Ctx, string, ...string) error); ok {
		r0 = rf(context, key, member...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SAddFullInfo provides a mock function with given fields: context, key, member
func (_m *Service) SAddFullInfo(context ctx.Ctx, key string, member ...string) (int64, error) {
	_va := make([]interface{}, len(member))
	for _i := range member {
		_va[_i] = member[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, context, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 int64
	if rf, ok := ret.Get(0).(func(ctx.Ctx, string, ...string) int64); ok {
		r0 = rf(context, key, member...)
	} else {
		r0 = ret.Get(0).(int64)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(ctx.Ctx, string, ...string) error); ok {
		r1 = rf(context, key, member...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SCard provides a mock function with given fields: context, key
func (_m *Service) SCard(context ctx.Ctx, key string) (int, error) {
	ret := _m.Called(context, key)

	var r0 int
	if rf, ok := ret.Get(0).(func(ctx.Ctx, string) int); ok {
		r0 = rf(context, key)
	} else {
		r0 = ret.Get(0).(int)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(ctx.Ctx, string) error); ok {
		r1 = rf(context, key)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SIsMember provides a mock function with given fields: context, key, member
func (_m *Service) SIsMember(context ctx.Ctx, key string, member string) (bool, error) {
	ret := _m.Called(context, key, member)

	var r0 bool
	if rf, ok := ret.Get(0).(func(ctx.Ctx, string, string) bool); ok {
		r0 = rf(context, key, member)
	} else {
		r0 = ret.Get(0).(bool)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(ctx.Ctx, string, string) error); ok {
		r1 = rf(context, key, member)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SMPop provides a mock function with given fields: context, key, count
func (_m *Service) SMPop(context ctx.Ctx, key string, count int) ([]string, error) {
	ret := _m.Called(context, key, count)

	var r0 []string
	if rf, ok := ret.Get(0).(func(ctx.Ctx, string, int) []string); ok {
		r0 = rf(context, key, count)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(ctx.Ctx, string, int) error); ok {
		r1 = rf(context, key, count)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SMembers provides a mock function with given fields: context, key
func (_m *Service) SMembers(context ctx.Ctx, key string) ([]string, error) {
	ret := _m.Called(context, key)

	var r0 []string
	if rf, ok := ret.Get(0).(func(ctx.Ctx, string) []string); ok {
		r0 = rf(context, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(ctx.Ctx, string) error); ok {
		r1 = rf(context, key)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SPop provides a mock function with given fields: context, key
func (_m *Service) SPop(context ctx.Ctx, key string) (string, error) {
	ret := _m.Called(context, key)

	var r0 string
	if rf, ok := ret.Get(0).(func(ctx.Ctx, string) string); ok {
		r0 = rf(context, key)
	} else {
		r0 = ret.Get(0).(string)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(ctx.Ctx, string) error); ok {
		r1 = rf(context, key)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SRem provides a mock function with given fields: context, key, member
func (_m *Service) SRem(context ctx.Ctx, key string, member ...string) error {
	_va := make([]interface{}, len(member))
	for _i := range member {
		_va[_i] = member[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, context, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 error
	if rf, ok := ret.Get(0).(func(ctx.Ctx, string, ...string) error); ok {
		r0 = rf(context, key, member...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SScan provides a mock function with given fields: context, key, cursor, count
func (_m *Service) SScan(context ctx.Ctx, key string, cursor int, count int) ([]string, int, error) {
	ret := _m.Called(context, key, cursor, count)

	var r0 []string
	if rf, ok := ret.Get(0).(func(ctx.Ctx, string, int, int) []string); ok {
		r0 = rf(context, key, cursor, count)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	var r1 int
	if rf, ok := ret.Get(1).(func(ctx.Ctx, string, int, int) int); ok {
		r1 = rf(context, key, cursor, count)
	} else {
		r1 = ret.Get(1).(int)
	}

	var r2 error
	if rf, ok := ret.Get(2).(func(ctx.Ctx, string, int, int) error); ok {
		r2 = rf(context, key, cursor, count)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// ScanMatch provides a mock function with given fields: context, cursor, match, count
func (_m *Service) ScanMatch(context ctx.Ctx, cursor int64, match string, count int) (int64, []string, error) {
	ret := _m.Called(context, cursor, match, count)

	var r0 int64
	if rf, ok := ret.Get(0).(func(ctx.Ctx, int64, string, int) int64); ok {
		r0 = rf(context, cursor, match, count)
	} else {
		r0 = ret.Get(0).(int64)
	}

	var r1 []string
	if rf, ok := ret.Get(1).(func(ctx.Ctx, int64, string, int) []string); ok {
		r1 = rf(context, cursor, match, count)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).([]string)
		}
	}

	var r2 error
	if rf, ok := ret.Get(2).(func(ctx.Ctx, int64, string, int) error); ok {
		r2 = rf(context, cursor, match, count)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// ScriptDo provides a mock function with given fields: context, hdl, keysAndArgs
func (_m *Service) ScriptDo(context ctx.Ctx, hdl *redis.ScriptHdl, keysAndArgs ...interface{}) (interface{}, error) {
	var _ca []interface{}
	_ca = append(_ca, context, hdl)
	_ca = append(_ca, keysAndArgs...)
	ret := _m.Called(_ca...)

	var r0 interface{}
	if rf, ok := ret.Get(0).(func(ctx.Ctx, *redis.ScriptHdl, ...interface{}) interface{}); ok {
		r0 = rf(context, hdl, keysAndArgs...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(interface{})
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(ctx.Ctx, *redis.ScriptHdl, ...interface{}) error); ok {
		r1 = rf(context, hdl, keysAndArgs...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Set provides a mock function with given fields: context, key, val, ttl
func (_m *Service) Set(context ctx.Ctx, key string, val []byte, ttl time.Duration) error {
	ret := _m.Called(context, key, val, ttl)

	var r0 error
	if rf, ok := ret.Get(0).(func(ctx.Ctx, string, []byte, time.Duration) error); ok {
		r0 = rf(context, key, val, ttl)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SetNX provides a mock function with given fields: context, key, val, expire
func (_m *Service) SetNX(context ctx.Ctx, key string, val []byte, expire time.Duration) error {
	ret := _m.Called(context, key, val, expire)

	var r0 error
	if rf, ok := ret.Get(0).(func(ctx.Ctx, string, []byte, time.Duration) error); ok {
		r0 = rf(context, key, val, expire)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SetStruct provides a mock function with given fields: context, key, val, ttl
func (_m *Service) SetStruct(context ctx.Ctx, key string, val interface{}, ttl time.Duration) error {
	ret := _m.Called(context, key, val, ttl)

	var r0 error
	if rf, ok := ret.Get(0).(func(ctx.Ctx, string, interface{}, time.Duration) error); ok {
		r0 = rf(context, key, val, ttl)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SetXX provides a mock function with given fields: context, key, val, ttl
func (_m *Service) SetXX(context ctx.Ctx, key string, val []byte, ttl time.Duration) error {
	ret := _m.Called(context, key, val, ttl)

	var r0 error
	if rf, ok := ret.Get(0).(func(ctx.Ctx, string, []byte, time.Duration) error); ok {
		r0 = rf(context, key, val, ttl)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SetZip provides a mock function with given fields: context, key, val, ttl
func (_m *Service) SetZip(context ctx.Ctx, key string, val []byte, ttl time.Duration) error {
	ret := _m.Called(context, key, val, ttl)

	var r0 error
	if rf, ok := ret.Get(0).(func(ctx.Ctx, string, []byte, time.Duration) error); ok {
		r0 = rf(context, key, val, ttl)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Strlen provides a mock function with given fields: context, key
func (_m *Service) Strlen(context ctx.Ctx, key string) (int, error) {
	ret := _m.Called(context, key)

	var r0 int
	if rf, ok := ret.Get(0).(func(ctx.Ctx, string) int); ok {
		r0 = rf(context, key)
	} else {
		r0 = ret.Get(0).(int)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(ctx.Ctx, string) error); ok {
		r1 = rf(context, key)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// TTL provides a mock function with given fields: context, key
func (_m *Service) TTL(context ctx.Ctx, key string) (int, error) {
	ret := _m.Called(context, key)

	var r0 int
	if rf, ok := ret.Get(0).(func(ctx.Ctx, string) int); ok {
		r0 = rf(context, key)
	} else {
		r0 = ret.Get(0).(int)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(ctx.Ctx, string) error); ok {
		r1 = rf(context, key)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Type provides a mock function with given fields: context, key
func (_m *Service) Type(context ctx.Ctx, key string) ([]byte, error) {
	ret := _m.Called(context, key)

	var r0 []byte
	if rf, ok := ret.Get(0).(func(ctx.Ctx, string) []byte); ok {
		r0 = rf(context, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(ctx.Ctx, string) error); ok {
		r1 = rf(context, key)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Unlink provides a mock function with given fields: context, key
func (_m *Service) Unlink(context ctx.Ctx, key ...string) (int, error) {
	_va := make([]interface{}, len(key))
	for _i := range key {
		_va[_i] = key[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, context)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 int
	if rf, ok := ret.Get(0).(func(ctx.Ctx, ...string) int); ok {
		r0 = rf(context, key...)
	} else {
		r0 = ret.Get(0).(int)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(ctx.Ctx, ...string) error); ok {
		r1 = rf(context, key...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ZAdd provides a mock function with given fields: context, key, memSco
func (_m *Service) ZAdd(context ctx.Ctx, key string, memSco map[string]int) error {
	ret := _m.Called(context, key, memSco)

	var r0 error
	if rf, ok := ret.Get(0).(func(ctx.Ctx, string, map[string]int) error); ok {
		r0 = rf(context, key, memSco)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ZAddFloat provides a mock function with given fields: context, key, memSco
func (_m *Service) ZAddFloat(context ctx.Ctx, key string, memSco map[string]float64) error {
	ret := _m.Called(context, key, memSco)

	var r0 error
	if rf, ok := ret.Get(0).(func(ctx.Ctx, string, map[string]float64) error); ok {
		r0 = rf(context, key, memSco)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ZAddNXFloat provides a mock function with given fields: context, key, memSco
func (_m *Service) ZAddNXFloat(context ctx.Ctx, key string, memSco map[string]float64) error {
	ret := _m.Called(context, key, memSco)

	var r0 error
	if rf, ok := ret.Get(0).(func(ctx.Ctx, string, map[string]float64) error); ok {
		r0 = rf(context, key, memSco)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ZAddXX provides a mock function with given fields: context, key, memSco
func (_m *Service) ZAddXX(context ctx.Ctx, key string, memSco map[string]int) error {
	ret := _m.Called(context, key, memSco)

	var r0 error
	if rf, ok := ret.Get(0).(func(ctx.Ctx, string, map[string]int) error); ok {
		r0 = rf(context, key, memSco)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ZCard provides a mock function with given fields: context, key
func (_m *Service) ZCard(context ctx.Ctx, key string) (int, error) {
	ret := _m.Called(context, key)

	var r0 int
	if rf, ok := ret.Get(0).(func(ctx.Ctx, string) int); ok {
		r0 = rf(context, key)
	} else {
		r0 = ret.Get(0).(int)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(ctx.Ctx, string) error); ok {
		r1 = rf(context, key)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ZCount provides a mock function with given fields: context, key, minScore, maxScore
func (_m *Service) ZCount(context ctx.Ctx, key string, minScore string, maxScore string) (int, error) {
	ret := _m.Called(context, key, minScore, maxScore)

	var r0 int
	if rf, ok := ret.Get(0).(func(ctx.Ctx, string, string, string) int); ok {
		r0 = rf(context, key, minScore, maxScore)
	} else {
		r0 = ret.Get(0).(int)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(ctx.Ctx, string, string, string) error); ok {
		r1 = rf(context, key, minScore, maxScore)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ZIncrby provides a mock function with given fields: context, key, member, val
func (_m *Service) ZIncrby(context ctx.Ctx, key string, member string, val int) (int, error) {
	ret := _m.Called(context, key, member, val)

	var r0 int
	if rf, ok := ret.Get(0).(func(ctx.Ctx, string, string, int) int); ok {
		r0 = rf(context, key, member, val)
	} else {
		r0 = ret.Get(0).(int)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(ctx.Ctx, string, string, int) error); ok {
		r1 = rf(context, key, member, val)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ZIncrbyFloat provides a mock function with given fields: context, key, member, val
func (_m *Service) ZIncrbyFloat(context ctx.Ctx, key string, member string, val float64) (float64, error) {
	ret := _m.Called(context, key, member, val)

	var r0 float64
	if rf, ok := ret.Get(0).(func(ctx.Ctx, string, string, float64) float64); ok {
		r0 = rf(context, key, member, val)
	} else {
		r0 = ret.Get(0).(float64)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(ctx.Ctx, string, string, float64) error); ok {
		r1 = rf(context, key, member, val)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ZPopMin provides a mock function with given fields: context, key, count
func (_m *Service) ZPopMin(context ctx.Ctx, key string, count int) ([]redis.ZFloatVal, error) {
	ret := _m.Called(context, key, count)

	var r0 []redis.ZFloatVal
	if rf, ok := ret.Get(0).(func(ctx.Ctx, string, int) []redis.ZFloatVal); ok {
		r0 = rf(context, key, count)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]redis.ZFloatVal)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(ctx.Ctx, string, int) error); ok {
		r1 = rf(context, key, count)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ZRange provides a mock function with given fields: context, key, offset, count
func (_m *Service) ZRange(context ctx.Ctx, key string, offset int, count int) ([]string, error) {
	ret := _m.Called(context, key, offset, count)

	var r0 []string
	if rf, ok := ret.Get(0).(func(ctx.Ctx, string, int, int) []string); ok {
		r0 = rf(context, key, offset, count)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(ctx.Ctx, string, int, int) error); ok {
		r1 = rf(context, key, offset, count)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ZRangeByScoreWithScore provides a mock function with given fields: context, key, minScore, maxScore
func (_m *Service) ZRangeByScoreWithScore(context ctx.Ctx, key string, minScore string, maxScore string) ([]redis.ZVal, error) {
	ret := _m.Called(context, key, minScore, maxScore)

	var r0 []redis.ZVal
	if rf, ok := ret.Get(0).(func(ctx.Ctx, string, string, string) []redis.ZVal); ok {
		r0 = rf(context, key, minScore, maxScore)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]redis.ZVal)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(ctx.Ctx, string, string, string) error); ok {
		r1 = rf(context, key, minScore, maxScore)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ZRem provides a mock function with given fields: context, key, members
func (_m *Service) ZRem(context ctx.Ctx, key string, members ...string) error {
	_va := make([]interface{}, len(members))
	for _i := range members {
		_va[_i] = members[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, context, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 error
	if rf, ok := ret.Get(0).(func(ctx.Ctx, string, ...string) error); ok {
		r0 = rf(context, key, members...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ZRemRangeByRank provides a mock function with given fields: context, key, start, stop
func (_m *Service) ZRemRangeByRank(context ctx.Ctx, key string, start int, stop int) (int, error) {
	ret := _m.Called(context, key, start, stop)

	var r0 int
	if rf, ok := ret.Get(0).(func(ctx.Ctx, string, int, int) int); ok {
		r0 = rf(context, key, start, stop)
	} else {
		r0 = ret.Get(0).(int)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(ctx.Ctx, string, int, int) error); ok {
		r1 = rf(context, key, start, stop)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ZRemRangeByScore provides a mock function with given fields: context, key, minScore, maxScore
func (_m *Service) ZRemRangeByScore(context ctx.Ctx, key string, minScore int, maxScore int) (int, error) {
	ret := _m.Called(context, key, minScore, maxScore)

	var r0 int
	if rf, ok := ret.Get(0).(func(ctx.Ctx, string, int, int) int); ok {
		r0 = rf(context, key, minScore, maxScore)
	} else {
		r0 = ret.Get(0).(int)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(ctx.Ctx, string, int, int) error); ok {
		r1 = rf(context, key, minScore, maxScore)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ZRevRank provides a mock function with given fields: context, key, member
func (_m *Service) ZRevRank(context ctx.Ctx, key string, member string) (int, error) {
	ret := _m.Called(context, key, member)

	var r0 int
	if rf, ok := ret.Get(0).(func(ctx.Ctx, string, string) int); ok {
		r0 = rf(context, key, member)
	} else {
		r0 = ret.Get(0).(int)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(ctx.Ctx, string, string) error); ok {
		r1 = rf(context, key, member)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ZRevrange provides a mock function with given fields: context, key, offset, count
func (_m *Service) ZRevrange(context ctx.Ctx, key string, offset int, count int) ([]string, error) {
	ret := _m.Called(context, key, offset, count)

	var r0 []string
	if rf, ok := ret.Get(0).(func(ctx.Ctx, string, int, int) []string); ok {
		r0 = rf(context, key, offset, count)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(ctx.Ctx, string, int, int) error); ok {
		r1 = rf(context, key, offset, count)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ZRevrangeByScoreWithFloatScore provides a mock function with given fields: context, key, minScore, maxScore
func (_m *Service) ZRevrangeByScoreWithFloatScore(context ctx.Ctx, key string, minScore string, maxScore string) ([]redis.ZFloatVal, error) {
	ret := _m.Called(context, key, minScore, maxScore)

	var r0 []redis.ZFloatVal
	if rf, ok := ret.Get(0).(func(ctx.Ctx, string, string, string) []redis.ZFloatVal); ok {
		r0 = rf(context, key, minScore, maxScore)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]redis.ZFloatVal)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(ctx.Ctx, string, string, string) error); ok {
		r1 = rf(context, key, minScore, maxScore)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ZRevrangeByScoreWithScore provides a mock function with given fields: context, key, minScore, maxScore
func (_m *Service) ZRevrangeByScoreWithScore(context ctx.Ctx, key string, minScore string, maxScore string) ([]redis.ZVal, error) {
	ret := _m.Called(context, key, minScore, maxScore)

	var r0 []redis.ZVal
	if rf, ok := ret.Get(0).(func(ctx.Ctx, string, string, string) []redis.ZVal); ok {
		r0 = rf(context, key, minScore, maxScore)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]redis.ZVal)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(ctx.Ctx, string, string, string) error); ok {
		r1 = rf(context, key, minScore, maxScore)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ZRevrangeFloatScore provides a mock function with given fields: context, key, offset, count
func (_m *Service) ZRevrangeFloatScore(context ctx.Ctx, key string, offset int, count int) ([]redis.ZFloatVal, error) {
	ret := _m.Called(context, key, offset, count)

	var r0 []redis.ZFloatVal
	if rf, ok := ret.Get(0).(func(ctx.Ctx, string, int, int) []redis.ZFloatVal); ok {
		r0 = rf(context, key, offset, count)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]redis.ZFloatVal)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(ctx.Ctx, string, int, int) error); ok {
		r1 = rf(context, key, offset, count)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ZRevrangeScore provides a mock function with given fields: context, key, offset, count
func (_m *Service) ZRevrangeScore(context ctx.Ctx, key string, offset int, count int) ([]redis.ZVal, error) {
	ret := _m.Called(context, key, offset, count)

	var r0 []redis.ZVal
	if rf, ok := ret.Get(0).(func(ctx.Ctx, string, int, int) []redis.ZVal); ok {
		r0 = rf(context, key, offset, count)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]redis.ZVal)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(ctx.Ctx, string, int, int) error); ok {
		r1 = rf(context, key, offset, count)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ZScan provides a mock function with given fields: context, key, cursor, limit
func (_m *Service) ZScan(context ctx.Ctx, key string, cursor int, limit int) (map[string]int, int, error) {
	ret := _m.Called(context, key, cursor, limit)

	var r0 map[string]int
	if rf, ok := ret.Get(0).(func(ctx.Ctx, string, int, int) map[string]int); ok {
		r0 = rf(context, key, cursor, limit)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string]int)
		}
	}

	var r1 int
	if rf, ok := ret.Get(1).(func(ctx.Ctx, string, int, int) int); ok {
		r1 = rf(context, key, cursor, limit)
	} else {
		r1 = ret.Get(1).(int)
	}

	var r2 error
	if rf, ok := ret.Get(2).(func(ctx.Ctx, string, int, int) error); ok {
		r2 = rf(context, key, cursor, limit)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// ZScore provides a mock function with given fields: context, key, member
func (_m *Service) ZScore(context ctx.Ctx, key string, member string) (int, error) {
	ret := _m.Called(context, key, member)

	var r0 int
	if rf, ok := ret.Get(0).(func(ctx.Ctx, string, string) int); ok {
		r0 = rf(context, key, member)
	} else {
		r0 = ret.Get(0).(int)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(ctx.Ctx, string, string) error); ok {
		r1 = rf(context, key, member)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ZScoreFloat provides a mock function with given fields: context, key, member
func (_m *Service) ZScoreFloat(context ctx.Ctx, key string, member string) (float64, error) {
	ret := _m.Called(context, key, member)

	var r0 float64
	if rf, ok := ret.Get(0).(func(ctx.Ctx, string, string) float64); ok {
		r0 = rf(context, key, member)
	} else {
		r0 = ret.Get(0).(float64)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(ctx.Ctx, string, string) error); ok {
		r1 = rf(context, key, member)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ZUnionStore provides a mock function with given fields: context, paris, dest
func (_m *Service) ZUnionStore(context ctx.Ctx, paris []redis.Pair, dest string) error {
	ret := _m.Called(context, paris, dest)

	var r0 error
	if rf, ok := ret.Get(0).(func(ctx.Ctx, []redis.Pair, string) error); ok {
		r0 = rf(context, paris, dest)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}
